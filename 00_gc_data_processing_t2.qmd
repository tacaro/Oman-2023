---
title: "gc data exploration"
format: html
editor: visual
---

## Load packages

```{r}
library(tidyverse) # Easily Install and Load the 'Tidyverse', CRAN v1.3.2
library(plotly) # Create Interactive Web Graphics via 'plotly.js', CRAN v4.10.1
library(reticulate) # Interface to 'Python', CRAN v1.28 
library(ggpmisc)
```

# Execute python script

This script parses GC data into a readable `.csv` file that we read into R. It requires the `reticulate` package. I've noticed a bug where this script will crash if chunk output is set to `console` instead of `inline`.

```{python}
import numpy as np
import pandas as pd
import os


# FUNCTION DEFINITION

def read_GC_RES_file(file_name):
    print("Reading file path: " + file_name)

    with open(file_name) as file:
        lines = file.readlines()

    sample_type = lines[34]
    column = lines[18]
    carrier = lines[20]

    file.close() # close the file

    file = open(file_name) # open the file again

    cleaned_array = [] # create an empty array

    for i, line in enumerate(file):

        if i < 42: # skip lines that have irrerlevant data
            continue

        else:
            line_array = line.strip().split(',')

            if len(line_array) == 1:

                # Skipping the rows that have an empty list (empty lines in the file)
                continue

            # List comprehension on each element, stripping it of quotes. 
            # Doesn't matter if it doesn't have quotes.
            new_array = [x.strip('\"') for x in line_array]

            # Append your new array to the storage array.
            cleaned_array.append(new_array)

    try:
        # Write the results
        data_array = np.array(cleaned_array)
        data_array = data_array[:,:5]
        # Write the relevant metadata
        df = pd.DataFrame(data_array, columns=['gas', 'retention_time', 'peak_area', 'peak_height', 'correction_factor'])
        # add the file name, removing newlines
        df['file_name'] = file_name.replace('\n', '') 
        # add the sample type (entered manually in program), removing newlines
        df['sample_type'] = sample_type.replace('\n', '') 
        # add column info, removing newlines
        df['column'] = column.replace('\n', '') 
        # add carrier info, removing newlines
        df['carrier'] = carrier.replace('\n', '') 
        return df
    except IndexError:
        print("Data file: " + file_name + " encountered an error. Check the file!")
        pass
    except ValueError:
        print("Data file: " + file_name + " encountered an error. Check the file!")
        pass


# EXECUTE

# If GC data is not in this directory, change this string!
GC_file_directory = "data/gc_data/1jun23/" 
GC_files = [f for f in os.listdir(GC_file_directory) if f.endswith(".RES") and "FID" in f]

appended_data = []

for res in GC_files:
    data = read_GC_RES_file(GC_file_directory + res)
    # store DataFrame in a list
    appended_data.append(data)

# See pd.concat documentation for more info on this operation
appended_data = pd.concat(appended_data)
# write DataFrame to csv
appended_data.to_csv("data/GC_Data_Table2.csv")

# close the current python session
quit
```

## Load data

```{r}
# Load GC raw data
gc <- read_csv("data/GC_Data_Table2.csv") |> 
  rename(gc_sample_id = sample_type) |> 
  # fix mislabeled gas name
  mutate(
    gas = case_when(
      gas == "C02" ~ "CO2",
      TRUE ~ gas
    )
  ) |> 
  # parse sample volume
  mutate(
    sample_volume = as.numeric(str_extract(gc_sample_id, "\\d+(\\.\\d+)?(?=ml)"))
  )


```

## Separate standards and samples

```{r}
standards <- gc |> 
  filter(
    str_detect(gc_sample_id, "mix")
  )

# and add metadata to sample tibble
samples <- gc |> 
  filter(
    str_detect(gc_sample_id, "BA")
  ) |> 
  mutate(
    well = case_when(
      str_detect(gc_sample_id, "BA4A") ~ "BA4A",
      str_detect(gc_sample_id, "BA3A") ~ "BA3A",
      str_detect(gc_sample_id, "BA1B") ~ "BA1B"
    ),
    depth = case_when(
      str_detect(gc_sample_id, "20") ~ 20,
      str_detect(gc_sample_id, "150") ~ 150,
      str_detect(gc_sample_id, "250") ~ 250,
      str_detect(gc_sample_id, "270") ~ 270
    ),
    amendment = case_when(
      str_detect(gc_sample_id, "AC") ~ "Acetate",
      str_detect(gc_sample_id, "FORM") ~ "Formate",
      str_detect(gc_sample_id, "BIC") ~ "Bicarbonate"
    )
  ) |> 
  mutate(
    sample_set = if_else(
      str_detect(gc_sample_id, "BT2"),
      true = "B",
      false = "A"
    )
  )
```

## Examine Standards

```{r}
standards |> 
  ggplot() +
  aes(
    x = sample_volume,
    y = peak_area,
    color = gas,
  ) +
  geom_smooth(
    method = "lm",
    formula = "y~x",
    color = "blue",
    linewidth = 0.5
  ) +
  geom_point(
    alpha = 0.5
  ) +
  coord_cartesian(
    xlim = c(0.1, 1),
    ylim = c(0, 1600)
    ) +
  scale_x_continuous(breaks = c(0.25, 0.5, 0.75)) +
  labs(
    x = "Injection volume (mL)",
    y = "Peak Area",
    color = "Gas",
    title = "1% Gas Mix Standard Curve"
  ) +
  theme_classic()
```

## Examine Samples

```{r}
samples |> 
  arrange(depth) |> 
  filter(sample_set == "B") |> 
  filter(gas == "CH4") |> 
  ggplot(
    aes(
      x = depth,
      y = peak_area,
      color = amendment
    )
  ) +
  geom_point() +
  geom_path(
    alpha = 0.25
  ) +
  facet_wrap(vars(well), scales = "free_x") +
  coord_flip() +
  scale_x_reverse() +
  ggsci::scale_color_aaas() +
  labs(
    y = "Peak Area",
    x = "Depth (m)",
    color = "Carbon Amendment"
  ) +
  theme_bw() +
  theme(
    legend.position = "bottom"
  )
```


# Generate standard curves

Here we calculate the number of moles injected in our standard curve as follows:

$$
n = \frac{PV}{RT}
$$
where n is the number of moles, P is pressure in `atm`, V is volume in `mL`, R is the gas constant $R = 0.082057338 \space L\cdot atm \cdot K^{-1} mol^{-1}$.


We calculate the number of moles per mL of gas, then the number of µg per mL of gas. The MW of $CH_4$ is 16.04 g/mol. The MW of CO2 is 44.01 g/mol.

$$
\begin{aligned}
g/mL &= mol * MW \\
µg/mL &= g/mL * (1e^-6)
\end{aligned}
$$


```{r}
volume_to_moles <- function(pressure_atm = 0.8, vol_mL, R = 0.082057338	, temp_C = 20) {
  # n = PV/RT
  # R = 0.082057338	L.atm.K-1.mol-1
  # average atmospheric pressure in boulder is about 0.8 atm
  temp_K = temp_C + 273 # convert ˚C to ˚K
  vol_L = vol_mL / 1000 # convert mL to L
  n_moles = (pressure_atm * vol_L) / (R * temp_K)
  return(n_moles)
}

volume_to_moles(pressure_atm = 0.8, vol_mL = 0.5, temp_C = 20) # 1.6637e-05
```

```{r}
gc_standard_curve <- standards |>
  ungroup() |> 
  relocate(gas, peak_area, sample_volume) |> 
  select(-c(retention_time, correction_factor, peak_height, gc_sample_id, column, carrier)) |> 
  mutate(
    mol_total = volume_to_moles(vol_mL = sample_volume), # moles of gas injected
    nmol_total = mol_total / 1E-9, # nmol gas injected (total),
    nmol_specific = nmol_total * .01, # 1% of the gas either CO2 or CH4
  )
```

```{r}
# Tidy the fits
CH4_curve_fit <- lm(data = filter(gc_standard_curve, gas == "CH4"), peak_area ~ nmol_specific) |> broom::tidy() |> 
  mutate(gas = "CH4") |> 
  select(-c(std.error, statistic, p.value)) |> 
  pivot_wider(names_from = term, values_from = estimate)
CH4_curve_slope <- CH4_curve_fit |> pull(nmol_specific)
CH4_curve_int <- CH4_curve_fit |> pull(`(Intercept)`)
CH4_curve_equation <- paste("y =", round(CH4_curve_slope, 2), "x", "+", round(CH4_curve_int, 2))

`CO2_curve_fit <- lm(data = filter(gc_standard_curve, gas == "CO2"), peak_area ~ nmol_specific) |> 
  broom::tidy() |> 
  mutate(gas = "CO2") |> 
  select(-c(std.error, statistic, p.value)) |> 
  pivot_wider(names_from = term, values_from = estimate)
CO2_curve_slope <- CO2_curve_fit |> pull(nmol_specific)
CO2_curve_int <- CO2_curve_fit |> pull(`(Intercept)`)
CO2_curve_equation <- paste("y =", round(CO2_curve_slope, 2), "x", "+", round(CO2_curve_int, 2))

CH4_curve_equation
CO2_curve_equation
```

Now we have a calibration that we can use to convert peak area to partial pressure:

$$
P = \frac{nRT}{V}
$$

but first we convert from peak area to $n$ nanomoles of gas injected:

$$
\begin{aligned}
A = nx + b \\
n = \frac{(A-b)}{x}
\end{aligned}
$$

where A is peak area, x is the defined slope, b is the y intercept, and n is the number of moles.

```{r}
peak_area_to_moles_per_mL <- function(peak_area, vol_mL, slope, intercept) {
  n_nmol = (peak_area - intercept) / slope # n = (A-b) / x
  mol = n_nmol / 1E9 # convert nanomoles to moles
  mol_per_mL = mol / vol_mL # convert to moles per mL gas
  return(
    case_when(
      mol_per_mL > 0 ~ mol_per_mL,
      mol_per_mL <= 0 ~ 0
    )
  )
}

peak_area_to_pressure <- function(peak_area, R = 0.082057338, temp_C = 20, vol_mL, slope, intercept) {
  # R = 0.082057338	L.atm.K-1.mol-1
  temp_K = 273 + temp_C # convert to ˚K
  vol_L = vol_mL / 1000 # convert to L
  n_nmol = (peak_area - intercept) / slope # n = (A-b) / x
  n_mol = n_nmol / 1E9 # convert nanomoles to moles
  pressure_atm = (n_mol * R * temp_K)/vol_L # P = nRT/V
  return(pressure_atm)
}

# Test it:
peak_area_to_pressure(25000, vol_mL = 0.5, slope = CO2_curve_slope, intercept = CO2_curve_int)
```

### Examine standard curve
```{r}
gc_standard_curve |> 
  ggplot(aes(
    x = nmol_specific,
    y = peak_area,
    color = gas
  )) +
  geom_point() +
  ggpmisc::stat_poly_eq(ggpmisc::use_label(c("eq", "R2"))) +
  ggpmisc::stat_poly_line(se = FALSE) +
  theme_bw() +
  labs(
    x = "nmol (Specific Gas)",
    y = "Peak Area"
  )
```



```{r}
# define molecular weights of CO2 and methane
MW.CO2 <- 44.01 #g/mol
MW.CH4 <- 16.04 #g/mol

gc_samples_processed <- samples |> 
  filter(gas != "CO") |> 
  mutate(
    # add the standard curve parameters
    fit_slope = case_when(
      gas == "CO2" ~ CO2_curve_slope,
      gas == "CH4" ~ CH4_curve_slope
    ),
    fit_int = case_when(
      gas == "CO2" ~ CO2_curve_int,
      gas == "CH4" ~ CH4_curve_int
    ),
    # Calculate moles per mL of gas
    mol_per_ml = peak_area_to_moles_per_mL(
      peak_area = peak_area, 
      vol_mL = sample_volume, 
      slope = fit_slope, 
      intercept = fit_int
      ),
    nmol_per_ml = mol_per_ml * 1E9,
    partial_P_atm = peak_area_to_pressure(
      peak_area = peak_area,
      vol_mL = sample_volume,
      slope = fit_slope,
      intercept = fit_int
    ),
    # Calculate mass per mL of gas
    ug_per_ml = case_when(
      gas == "CO2" ~ (mol_per_ml * MW.CO2) * 1e-6,
      gas == "CH4" ~ (mol_per_ml * MW.CH4) * 1e-6
    )
  )
```


# Export and cache

```{r}
saveRDS(object = gc_samples_processed, file = "cache/gc_samples1.RDS")
```

