#filter(Identifier1 == "NBS18" |Identifier1 == "Merck.UTSA") %>% #| Identifier1 == "CU YULE"
rename(std.name = Identifier1)
scale.corr <-  left_join(scale.stds, C.accepted, by = "std.name") %>%
select(std.name, C.acc, col_in_data) %>%
rename(d13C = col_in_data)
# safety checks
if (!col_in_data %in% names(data)) stop("this column does not exist in data or stds table: ", col_in_data, call. = FALSE)
# regression
m <- lm(scale.corr$C.acc ~ scale.corr$d13C)
scale.slopeC<-(coef(m)[[2]])
scale.interC<-(coef(m)[[1]])
R2 <- summary(m)$r.squared
S <- summary(m)$sigma
d13C.error.S <- S
# apply correction
data <- data %>%
mutate_(d13C.scale = lazyeval::interp(~scale.slopeC * var + scale.interC, var = as.name(col_in_data)))
stds <- stds %>%
mutate_(d13C.scale = lazyeval::interp(~scale.slopeC * var + scale.interC, var = as.name(col_in_data)))
C.scale.all <-
ggplot(scale.corr, aes(x=d13C, y=C.acc)) +
geom_smooth(method="lm", color = "blue") +
geom_point(data=filter(data, d18O.sd<d18O.sd.cutoff), aes_string(x=col_in_data, y="d13C.scale"), shape=23, fill="red", size = 2) +
geom_point(shape=21, fill="blue", size = 2) +
geom_text(
x = max(scale.corr$d13C),
y = max(scale.corr$C.acc),
label = str_interp("C.acc = $[.2f]{slope} ${var} + $[.2f]{intercept} (R2: $[.4f]{R2}) (S: $[.3f]{S})",
list(slope = scale.slopeC, intercept = scale.interC, var = col_for_scale_C, R2 = R2, S = S)),
size = 4, hjust=1.1, vjust=0, colour="blue") +
labs(x = col_for_scale_C) +
theme_bw()
C.scale.all
scaleC.mon<-subset(stds, Identifier1==mon.std)
scaleC.dis<-subset(stds, Identifier1==dis.std)
scaleC.dis2<-subset(stds, Identifier1==dis2.std)
scaleC.corr<-subset(stds, Identifier1==corr.std)
(scaleC.mon.mean<-mean(scaleC.mon$d13C.scale))
(scaleC.mon.sd<-sd(scaleC.mon$d13C.scale))
C.stds.table$scaleC.mean <- c(mean(scaleC.corr$d13C.scale), scaleC.mon.mean, mean(scaleC.dis$d13C.scale), mean(scaleC.dis2$d13C.scale))
C.stds.table$scaleC.sd <- c(sd(scaleC.corr$d13C.scale), scaleC.mon.sd, sd(scaleC.dis$d13C.scale), sd(scaleC.dis2$d13C.scale))
offsetO<-subset(stds, Identifier1==corr.std)
(offsetO.mean<-mean(offsetO$d18O.raw))
(offsetO.sd<-sd(offsetO$d18O.raw))
offsetO$d18O.offset <- offsetO$d18O.raw +  (O.acc - offsetO.mean)
(offsetcorrO.mean<-mean(offsetO$d18O.offset))
(offsetcorrO.sd<-sd(offsetO$d18O.offset))
d18O.offset<-ggplot(offsetO, aes(x=area44, y=d18O.offset, shape=type)) +
geom_point(fill="orange", size=3) +
geom_hline(yintercept=offsetcorrO.mean, colour="orange") +
geom_hline(yintercept=offsetcorrO.mean + offsetcorrO.sd, colour="orange", linetype="dashed") +
geom_hline(yintercept=offsetcorrO.mean - offsetcorrO.sd, colour="orange", linetype="dashed") +
geom_hline(yintercept=offsetcorrO.mean + 2*offsetcorrO.sd, colour="orange", linetype=3) +
geom_hline(yintercept=offsetcorrO.mean - 2*offsetcorrO.sd, colour="orange", linetype=3) +
scale_shape_manual(values=c(21,22,23,24,25)) +
annotate("text", y = offsetcorrO.mean + 0.01, x = min(offsetO$area44),
label = paste0("mean: ", sprintf("%.2f", offsetcorrO.mean), " \U00B1 ", sprintf("%.2f", offsetcorrO.sd, 2), " \U2030 (1 sd)"),
size = 4, hjust=0, vjust=0, parse=FALSE, colour="black") +
theme_bw()
d18O.offset.mass<-ggplot (stds, aes(x=mass, y=area44)) +
stat_smooth(method="lm") +
geom_point(data=offsetO, aes(x=mass, y=area44), shape=21, fill="orange", size = 2) +
theme_bw()
multiplot(d18O.offset, d18O.offset.mass, cols=2)
#apply offset correction to whole dataset
data$d18O.offset <- data$d18O.raw +  (O.acc - offsetO.mean)
stds$d18O.offset <- stds$d18O.raw +  (O.acc - offsetO.mean)
#make monitoring standard dataset and dataset for additional standards used later for discrimination correction
offsetO.mon <- subset(stds, Identifier1==mon.std)
offsetO.dis <- subset(stds, Identifier1==dis.std)
offsetO.dis2 <- subset(stds, Identifier1==dis2.std)
#check monitoring standard response
(offsetO.mon.mean<-mean(offsetO.mon$d18O.offset))
(offsetO.mon.sd<-sd(offsetO.mon$d18O.offset))
O.stds.table$offsetO.mean <- c(offsetcorrO.mean, offsetO.mon.mean, mean(offsetO.dis$d18O.offset), mean(offsetO.dis2$d18O.offset))
O.stds.table$offsetO.sd <- c(offsetcorrO.sd, offsetO.mon.sd, sd(offsetO.dis$d18O.offset), sd(offsetO.dis2$d18O.offset))
O.mon.offset<-ggplot(offsetO.mon, aes(x=area44, y=d18O.offset)) +
geom_point(shape=21, fill="orange") +
geom_hline(yintercept=offsetO.mon.mean, colour="orange") +
geom_hline(yintercept=offsetO.mon.mean + offsetO.mon.sd, colour="orange", linetype="dashed") +
geom_hline(yintercept=offsetO.mon.mean - offsetO.mon.sd, colour="orange", linetype="dashed") +
geom_hline(yintercept=offsetO.mon.mean + 2*offsetO.mon.sd, colour="orange", linetype=3) +
geom_hline(yintercept=offsetO.mon.mean - 2*offsetO.mon.sd, colour="orange", linetype=3) +
annotate("text", y = offsetO.mon.mean +0.01, x = min(offsetO.mon$area44), label = paste0("mean: ", sprintf("%.2f", offsetO.mon.mean), " \U00B1 ", sprintf("%.2f", offsetO.mon.sd, 2), " \U2030 (1 sd)"), size = 4, hjust=0, vjust=0, parse=FALSE) +
theme_bw()
O.mon.offset.mass<-ggplot (stds, aes(x=mass, y=area44)) +
stat_smooth(method="lm") +
geom_point(data=offsetO.mon, aes(x=mass, y=area44), shape=21, fill="orange", size = 2) +
theme_bw()
multiplot(O.mon.offset, O.mon.offset.mass, cols=2)
driftO<-subset(stds, type=="drift.std")
drift.slopeO<-(coef(lm(driftO$d18O.raw ~ driftO$row))[[2]])
drift.interO<-(coef(lm(driftO$d18O.raw ~ driftO$row))[[1]])
#drift check
driftO$d18O.drift<- driftO$d18O.raw + (O.acc - (drift.slopeO * driftO$row + drift.interO))
(driftO.mean<-mean(driftO$d18O.drift))
(driftO.sd<-sd(driftO$d18O.drift))
O.drift<-ggplot(driftO, aes(x=row, y=d18O.raw)) +
geom_smooth(method=lm, colour="black") +
annotate("text", x = min(driftO$row), y = max(driftO$d18O.raw + 0.01), label = lm_eqn(driftO$row, driftO$d18O.raw),  size = 4, hjust=0, vjust=0, parse=TRUE, colour="black") +
geom_point(shape=21, fill="black", size=2) +
geom_point(aes(x=row, y=d18O.drift), fill="red", shape=22, size=2) +
geom_hline(aes(yintercept=O.acc), size=.5) +
geom_hline(yintercept = driftO.mean + driftO.sd, colour="red", linetype="dashed") +
geom_hline(yintercept = driftO.mean - driftO.sd, colour="red", linetype="dashed") +
geom_hline(yintercept = driftO.mean + 2*driftO.sd, colour="red", linetype=3) +
geom_hline(yintercept = driftO.mean - 2*driftO.sd, colour="red", linetype=3) +
annotate("text",
y = driftO.mean +0.01,
x = min(driftO$row),
label = paste0("mean: ", sprintf("%.2f", driftO.mean), " \U00B1 ", sprintf("%.2f", driftO.sd, 2), " \U2030 (1 sd)"),
size = 4, hjust=0, vjust=0, parse=FALSE) +
theme_bw()
O.drift.mass<-ggplot(stds, aes(x=mass, y=area44)) +
stat_smooth(method="lm") +
geom_point(data=driftO, aes(x=mass, y=area44), shape=21, fill="red", size=3) +
theme_bw()
multiplot(O.drift, O.drift.mass, cols=2)
data$d18O.drift <- data$d18O.raw +  (O.acc - (drift.slopeO * data$row + drift.interO))
stds$d18O.drift <- stds$d18O.raw +  (O.acc - (drift.slopeO * stds$row + drift.interO))
driftO.mon<-subset(stds, Identifier1==mon.std)
driftO.dis <- subset(stds, Identifier1==dis.std)
driftO.dis2 <- subset(stds, Identifier1==dis2.std)
(driftO.mon.mean<-mean(driftO.mon$d18O.drift))
(driftO.mon.sd<-sd(driftO.mon$d18O.drift))
O.stds.table$driftO.mean <- c(driftO.mean, driftO.mon.mean, mean(driftO.dis$d18O.drift), mean(driftO.dis2$d18O.drift))
O.stds.table$driftO.sd <- c(driftO.sd, driftO.mon.sd, sd(driftO.dis$d18O.drift), sd(driftO.dis2$d18O.drift))
O.mon.drift<-ggplot(driftO.mon, aes(x=area44, y=d18O.drift)) +
geom_point(shape=21, fill="red") +
geom_hline(yintercept = driftO.mon.mean, colour="red") +
geom_hline(yintercept = driftO.mon.mean + driftO.mon.sd, colour="red", linetype="dashed") +
geom_hline(yintercept = driftO.mon.mean - driftO.mon.sd, colour="red", linetype="dashed") +
geom_hline(yintercept = driftO.mon.mean + 2*driftO.mon.sd, colour="red", linetype=3) +
geom_hline(yintercept = driftO.mon.mean - 2*driftO.mon.sd, colour="red", linetype=3) +
annotate("text",
y = driftO.mon.mean +0.01,
x = min(driftO.mon$area44),
label = paste0("mean: ", sprintf("%.2f", driftO.mon.mean), " \U00B1 ", sprintf("%.2f", driftO.mon.sd, 2), " \U2030 (1 sd)"),
size = 4, hjust=0, vjust=0, parse=FALSE, colour="red")
O.mon.drift.mass<-ggplot (stds, aes(x=mass, y=area44)) +
stat_smooth(method="lm") +
geom_point(data=driftO.mon, aes(x=mass, y=area44), shape=21, fill="red", size = 2) +
theme_bw()
multiplot(O.mon.drift, O.mon.drift.mass, cols=2)
linO<-subset(stds, type=="lin.std")
lin.slopeO<-(coef(lm(linO$d18O.raw ~ linO$inv.area44))[[2]])
lin.interO<-(coef(lm(linO$d18O.raw ~ linO$inv.area44))[[1]])
#linearity check
linO$d18O.lin<-linO$d18O.raw + (O.acc - (lin.slopeO * linO$inv.area44 + lin.interO))
(linO.mean<-mean(linO$d18O.lin))
(linO.sd<-sd(linO$d18O.lin))
O.lin.area44<-ggplot(linO, aes(x=area44, y=d18O.raw)) +
geom_point(shape=21, fill="blue") +
geom_smooth()
O.lincorr.invarea<-ggplot(linO, aes(x=inv.area44, y=d18O.raw)) +
geom_smooth(method=lm) +
annotate("text", x = min(linO$inv.area44), y = max(linO$d18O.raw + 0.01), label = lm_eqn(linO$inv.area44, linO$d18O.raw),  size = 4, hjust=0, vjust=0, parse=TRUE) +
geom_point(shape=21, fill="black", size=2) +
geom_point(aes(x=inv.area44, y=d18O.lin), fill="red", shape=22) +
geom_hline(aes(yintercept=O.acc), size=.5) +
geom_hline(yintercept = linO.mean + linO.sd, colour="red", linetype="dashed") +
geom_hline(yintercept = linO.mean - linO.sd, colour="red", linetype="dashed") +
geom_hline(yintercept = linO.mean + 2*linO.sd, colour="red", linetype=3) +
geom_hline(yintercept = linO.mean - 2*linO.sd, colour="red", linetype=3) +
annotate("text",
y = linO.mean +0.01,
x = min(linO$inv.area44),
label = paste0("mean: ", sprintf("%.2f", linO.mean), " \U00B1 ", sprintf("%.2f", linO.sd, 2), " \U2030 (1 sd)"),
size = 4, hjust=0, vjust=0, parse=FALSE) +
theme_bw()
O.lin.mass<-ggplot (stds, aes(x=mass, y=area44)) +
stat_smooth(method="lm") +
geom_point(data=linO, aes(x=mass, y=area44), shape=21, fill="blue", size = 2) +
theme_bw()
multiplot(O.lin.area44, O.lincorr.invarea, O.lin.mass, cols=3)
data$d18O.lin <- data$d18O.raw +  (O.acc - (lin.slopeO * data$inv.area44 + lin.interO))
stds$d18O.lin <- stds$d18O.raw +  (O.acc - (lin.slopeO * stds$inv.area44 + lin.interO))
linO.mon<-subset(stds, Identifier1==mon.std)
linO.dis<-subset(stds, Identifier1==dis.std)
linO.dis2<-subset(stds, Identifier1==dis2.std)
(linO.mon.mean <- mean(linO.mon$d18O.lin))
(linO.mon.sd<-sd(linO.mon$d18O.lin))
O.stds.table$linO.mean <- c(linO.mean, linO.mon.mean, mean(linO.dis$d18O.lin), mean(linO.dis2$d18O.lin))
O.stds.table$linO.sd <- c(linO.sd, linO.mon.sd, sd(linO.dis$d18O.lin), sd(linO.dis2$d18O.lin))
O.mon.lin<-ggplot(linO.mon, aes(x=area44, y=d18O.lin)) +
geom_point(shape=21, fill="blue") +
geom_hline(yintercept = linO.mon.mean, colour="blue") +
geom_hline(yintercept = linO.mon.mean + linO.mon.sd, colour="blue", linetype="dashed") +
geom_hline(yintercept = linO.mon.mean - linO.mon.sd, colour="blue", linetype="dashed") +
geom_hline(yintercept = linO.mon.mean + 2*linO.mon.sd, colour="blue", linetype=3) +
geom_hline(yintercept = linO.mon.mean - 2*linO.mon.sd, colour="blue", linetype=3) +
annotate("text",
y = linO.mon.mean +0.01,
x = min(linO.mon$area44),
label = paste0("mean: ", sprintf("%.2f", linO.mon.mean), " \U00B1 ", sprintf("%.2f", linO.mon.sd, 2), " \U2030 (1 sd)"),
size = 4, hjust=0, vjust=0, parse=FALSE, colour="blue")
O.mon.lin.mass<-ggplot (stds, aes(x=mass, y=area44)) +
stat_smooth(method="lm") +
geom_point(data=linO.mon, aes(x=mass, y=area44), shape=21, fill="blue", size = 2) +
theme_bw()
multiplot(O.mon.lin, O.mon.lin.mass, cols=2)
lindriftO <- merge(driftO, data[c("row", "d18O.lin")], by.x="row", by.y="row", all.x=TRUE, all.y=FALSE, sort=FALSE)
lindrift.slopeO<-(coef(lm(lindriftO$d18O.lin ~ lindriftO$row))[[2]])
lindrift.interO<-(coef(lm(lindriftO$d18O.lin ~ lindriftO$row))[[1]])
#drift check
lindriftO$d18O.lindrift<- lindriftO$d18O.lin + (O.acc - (lindrift.slopeO * lindriftO$row + lindrift.interO))
(lindriftO.mean<-mean(lindriftO$d18O.drift))
(lindriftO.sd<-sd(lindriftO$d18O.drift))
O.lindrift<-ggplot(lindriftO, aes(x=row, y=d18O.lin)) +
geom_smooth(method=lm, colour="black") +
annotate("text", x = min(lindriftO$row), y = max(lindriftO$d18O.lin + 0.01), label = lm_eqn(lindriftO$row, lindriftO$d18O.lin),  size = 4, hjust=0, vjust=0, parse=TRUE, colour="black") +
geom_point(shape=21, fill="black", size=2) +
geom_point(aes(x=row, y=d18O.lindrift), fill="red", shape=22, size=2) +
geom_hline(aes(yintercept=O.acc), size=.5) +
geom_hline(yintercept = lindriftO.mean + lindriftO.sd, colour="red", linetype="dashed") +
geom_hline(yintercept = lindriftO.mean - lindriftO.sd, colour="red", linetype="dashed") +
geom_hline(yintercept = lindriftO.mean + 2*lindriftO.sd, colour="red", linetype=3) +
geom_hline(yintercept = lindriftO.mean - 2*lindriftO.sd, colour="red", linetype=3) +
annotate("text",
y = lindriftO.mean +0.01,
x = min(lindriftO$row),
label = paste0("mean: ", sprintf("%.2f", lindriftO.mean), " \U00B1 ", sprintf("%.2f", lindriftO.sd, 2), " \U2030 (1 sd)"),
size = 4, hjust=0, vjust=0, parse=FALSE) +
theme_bw()
O.lindrift.mass<-ggplot(stds, aes(x=mass, y=area44)) +
stat_smooth(method="lm") +
geom_point(data=lindriftO, aes(x=mass, y=area44), shape=21, fill="red", size=3) +
theme_bw()
multiplot(O.lindrift, O.lindrift.mass, cols=2)
data$d18O.lindrift <- data$d18O.lin +  (O.acc - (lindrift.slopeO * data$row + lindrift.interO))
stds$d18O.lindrift <- stds$d18O.lin +  (O.acc - (lindrift.slopeO * stds$row + lindrift.interO))
lindriftO.mon<-subset(stds, Identifier1==mon.std)
lindriftO.dis<-subset(stds, Identifier1==dis.std)
lindriftO.dis2<-subset(stds, Identifier1==dis2.std)
(lindriftO.mon.mean<-mean(lindriftO.mon$d18O.lindrift))
(lindriftO.mon.sd<-sd(lindriftO.mon$d18O.lindrift))
O.stds.table$lindriftO.mean <- cbind(c(lindriftO.mean, lindriftO.mon.mean, mean(lindriftO.dis$d18O.lindrift),  mean(lindriftO.dis2$d18O.lindrift)))
O.stds.table$lindriftO.sd <- cbind(c(lindriftO.sd, lindriftO.mon.sd, sd(lindriftO.dis$d18O.lindrift), sd(lindriftO.dis2$d18O.lindrift)))
O.mon.drift<-ggplot(lindriftO.mon, aes(x=area44, y=d18O.lindrift)) +
geom_point(shape=21, fill="red") +
geom_hline(yintercept = lindriftO.mon.mean, colour="red") +
geom_hline(yintercept = lindriftO.mon.mean + lindriftO.mon.sd, colour="red", linetype="dashed") +
geom_hline(yintercept = lindriftO.mon.mean - lindriftO.mon.sd, colour="red", linetype="dashed") +
geom_hline(yintercept = lindriftO.mon.mean + 2*lindriftO.mon.sd, colour="red", linetype=3) +
geom_hline(yintercept = lindriftO.mon.mean - 2*lindriftO.mon.sd, colour="red", linetype=3) +
annotate("text",
y = lindriftO.mon.mean +0.01,
x = min(lindriftO.mon$area44),
label = paste0("mean: ", sprintf("%.2f", lindriftO.mon.mean), " \U00B1 ", sprintf("%.2f", lindriftO.mon.sd, 2), " \U2030 (1 sd)"),
size = 4, hjust=0, vjust=0, parse=FALSE, colour="red")
O.mon.drift.mass<-ggplot (stds, aes(x=mass, y=area44)) +
stat_smooth(method="lm") +
geom_point(data=lindriftO.mon, aes(x=mass, y=area44), shape=21, fill="red", size = 2) +
theme_bw()
multiplot(O.mon.drift, O.mon.drift.mass, cols=2)
# replace the character string here with the correction column you want to use
col_for_scale_O <- "lindrift"  # options to substitute in here are: "raw" or "offset" or "drift" or  "lin" or  "lindrift"
#make new table of measured scale correction values versus the accepted values
col_in_data <- paste0("d18O.", col_for_scale_O)
O.accepted <- O.stds.table %>%
select(std.name, O.acc)
scale.stds <- stds %>%
#filter(Identifier1 == "NBS18" | Identifier1 == "YULE") %>%
rename(std.name = Identifier1)
scale.corr <-  left_join(scale.stds, O.accepted, by = "std.name") %>%
select(std.name, O.acc, col_in_data) %>%
rename(d18O = col_in_data)
# safety checks
if (!col_in_data %in% names(data)) stop("this column does not exist in data or stds table: ", col_in_data, call. = FALSE)
# regression
m <- lm(scale.corr$O.acc ~ scale.corr$d18O)
scale.slopeO<-(coef(m)[[2]])
scale.interO<-(coef(m)[[1]])
R2 <- summary(m)$r.squared
S <- summary(m)$sigma
d18O.error.S <- S
# apply correction
data <- data %>%
mutate_(d18O.scale = lazyeval::interp(~scale.slopeO * var + scale.interO, var = as.name(col_in_data)))
stds <- stds %>%
mutate_(d18O.scale = lazyeval::interp(~scale.slopeO * var + scale.interO, var = as.name(col_in_data)))
O.scale.all <-
ggplot(scale.corr, aes(x=d18O, y=O.acc)) +
geom_smooth(method="lm", color = "blue") +
geom_point(data=filter(data, d18O.sd<d18O.sd.cutoff), aes_string(x=col_in_data, y="d18O.scale"), shape=23, fill="red", size = 2) +
geom_point(shape=21, fill="blue", size = 2) +
geom_text(
x = max(scale.corr$d18O),
y = max(scale.corr$O.acc),
label = str_interp("O.acc = $[.2f]{slope} ${var} + $[.2f]{intercept} (R2: $[.4f]{R2}) (S: $[.3f]{S})",
list(slope = scale.slopeO, intercept = scale.interO, var = col_for_scale_O, R2 = R2, S = S)),
size = 4, hjust=1.1, vjust=0, colour="blue") +
labs(x = col_for_scale_O) +
theme_bw()
O.scale.all
scaleO.mon<-subset(stds, Identifier1==mon.std)
scaleO.dis<-subset(stds, Identifier1==dis.std)
scaleO.dis2<-subset(stds, Identifier1==dis2.std)
scaleO.corr<-subset(stds, Identifier1==corr.std)
(scaleO.mon.mean<-mean(scaleO.mon$d18O.scale))
(scaleO.mon.sd<-sd(scaleO.mon$d18O.scale))
O.stds.table$scaleO.mean <- c(mean(scaleO.corr$d18O.scale), scaleO.mon.mean, mean(scaleO.dis$d18O.scale), mean(scaleO.dis2$d18O.scale))
O.stds.table$scaleO.sd <- c(sd(scaleO.corr$d18O.scale), scaleO.mon.sd, sd(scaleO.dis$d18O.scale), sd(scaleO.dis2$d18O.scale))
View(linC)
?lm
MM_CaCO3 <- 100.0869 # the molecular weight of CaCO3 in g/mol
vol_H2O_sample_ml <- 1 # the volume of the liquid sample in the exetainer (CHANGE IF DIFFERENT VOLUME USED!)
# Remove problematic standards from our set of linear standards (defined earlier as linC)
linC <- linC %>%
filter(!Analysis %in% c("26752", "26753"))
# Calculate the moles of CO2 expected when acidifying
# here, mass is the mass of CaCO3 standard weighed out in ug (vonverted to g by 1e-6)
linC <- linC %>% mutate(mol_CO2_total_expected = mass * 1e-6 / MM_CaCO3) # add column for total moles CO2 expected
# Calculate [DIC] of initial water sample by dividing total moles CO2 by volume of water
# [DIC] is calculated first as molar (M) --> moles / L (where mL to L is *1e-3)
# We then multiply by 1e6 to convert M to uM:
linC <- linC %>% mutate(DIC_uM = mol_CO2_total_expected / (vol_H2O_sample_ml * 1e-3) * 1e6)
# Now we calculate a linear model of calculated DIC versus area of our standards:
# y ~ x (dependent ~ independent)
DIClm <- lm(data = linC, DIC_uM ~ area44)
DIC_lm_tidy <- broom::tidy(DIClm)
View(DIC_lm_tidy)
View(DIC_lm_tidy)
DIClm_slope <- (coef(DIClm)[[2]])
DIClm_yint <- (coef(DIClm)[[1]])
DIClm_slope <- DIC_lm_tidy %>% filter(term == "area44") %>% pull(estimate)
MM_CaCO3 <- 100.0869 # the molecular weight of CaCO3 in g/mol
vol_H2O_sample_ml <- 1 # the volume of the liquid sample in the exetainer (CHANGE IF DIFFERENT VOLUME USED!)
# Remove problematic standards from our set of linear standards (defined earlier as linC)
linC <- linC %>%
filter(!Analysis %in% c("26752", "26753"))
# Calculate the moles of CO2 expected when acidifying
# here, mass is the mass of CaCO3 standard weighed out in ug (vonverted to g by 1e-6)
linC <- linC %>% mutate(mol_CO2_total_expected = mass * 1e-6 / MM_CaCO3) # add column for total moles CO2 expected
# Calculate [DIC] of initial water sample by dividing total moles CO2 by volume of water
# [DIC] is calculated first as molar (M) --> moles / L (where mL to L is *1e-3)
# We then multiply by 1e6 to convert M to uM:
linC <- linC %>% mutate(DIC_uM = mol_CO2_total_expected / (vol_H2O_sample_ml * 1e-3) * 1e6)
# Now we calculate a linear model of calculated DIC versus area of our standards:
# y ~ x (dependent ~ independent)
DIClm <- lm(data = linC, DIC_uM ~ area44)
DIC_lm_tidy <- broom::tidy(DIClm) # tidy up the linear model using broom: creates a tibble of fit params
DIClm_slope <- DIC_lm_tidy %>% filter(term == "area44") %>% pull(estimate)
DIClm_yint <- DIC_lm_tidy %>% filter(term == "(Intercept)") %>% pull(estimate)
calib_DIC_4  <-
ggplot(linC, aes(y=DIC_uM, x=area44)) +
geom_smooth(method="lm", color = "blue") +
geom_point(shape=21, fill="black", size = 2)+
geom_smooth(method = "lm", formula = "y~x") +
scale_y_continuous(name = latex2exp::TeX("estimated $\\lbrack$$\\Sigma$CO$_2$$\\rbrack$ (µM)"))+
scale_x_continuous(name = latex2exp::TeX("area44 (Vs)"))+
labs(
caption = paste0("y = ", DIClm_slope, "x + ", DIClm_yint)
) +
theme_bw()
calib_DIC_4
# make interactive plot
calib_DIC_5  <-
ggplot(linC, aes(y=DIC_uM, x=area44, label=Analysis))+
geom_point()+
theme_bw()
calib_DIC_5 %>% ggplotly()
# apply correction to data
data <- data %>%
mutate(DICuM = DIClm_slope * area44 + DIClm_yint)
data %>%
ggplot(
aes(
x = area44,
y = DICuM
)
) +
geom_point() +
geom_smooth(
method = "lm",
formula = "y~x"
)
data %>%
ggplot(
aes(
x = area44,
y = DICuM
)
) +
geom_point() +
geom_smooth(
method = "lm",
formula = "y~x"
) +
labs(
title = "[DIC] (uM) of samples"
) +
theme_bw()
data %>%
mutate(
DICuM = as.numeric(
inverse.predict(
object = DIClm,
newdata = area44,
alpha = 0.5
)
)
)
library(isoprocessor) # processing isotope data files
#devtools::install_github("isoverse/isoprocessor")
library(isoprocessor) # processing isotope data files
library(tidyverse) # dplyr, tidyr, ggplot, etc.
library(openxlsx) # read/write from excel
library(plotly) # interactive plots
library(isoreader) # reading isotope data files
library(chemcal) # calculations from standard curve
install.packages("chemCal")
#devtools::install_github("isoverse/isoprocessor")
library(isoprocessor) # processing isotope data files
library(tidyverse) # dplyr, tidyr, ggplot, etc.
library(openxlsx) # read/write from excel
library(plotly) # interactive plots
library(isoreader) # reading isotope data files
library(chemcal) # calculations from standard curve
library(chemcal) # calculations from standard curve
install.packages("chemCal")
library(chemcal) # calculations from standard curve
#devtools::install_github("isoverse/isoprocessor")
library(isoprocessor) # processing isotope data files
library(tidyverse) # dplyr, tidyr, ggplot, etc.
library(openxlsx) # read/write from excel
library(plotly) # interactive plots
library(isoreader) # reading isotope data files
library(chemcal) # calculations from standard curve
#devtools::install_github("isoverse/isoprocessor")
library(isoprocessor) # processing isotope data files
library(tidyverse) # dplyr, tidyr, ggplot, etc.
library(openxlsx) # read/write from excel
library(plotly) # interactive plots
library(isoreader) # reading isotope data files
library(chemcal) # calculations from standard curve
library(chemcal) # calculations from standard curve
.libPaths()
install.packages("chemCal")
.libPaths()
install.packages("chemcal", lib = "C:/Users/CUBESSIL/Documents/R/win-library/3.6")
install.packages("chemCal", lib = "C:/Users/CUBESSIL/Documents/R/win-library/3.6")
library(chemcal) # calculations from standard curve
.libPaths()
#devtools::install_github("isoverse/isoprocessor")
library(isoprocessor) # processing isotope data files
library(tidyverse) # dplyr, tidyr, ggplot, etc.
library(openxlsx) # read/write from excel
library(plotly) # interactive plots
library(isoreader) # reading isotope data files
library(chemcal) # calculations from standard curve
#devtools::install_github("isoverse/isoprocessor")
library(isoprocessor) # processing isotope data files
library(tidyverse) # dplyr, tidyr, ggplot, etc.
library(openxlsx) # read/write from excel
library(plotly) # interactive plots
library(isoreader) # reading isotope data files
library(chemcal) # calculations from standard curve
#devtools::install_github("isoverse/isoprocessor")
library(isoprocessor) # processing isotope data files
devtools::install_github("isoverse/isoprocessor")
library(isoreader) # reading isotope data files
devtools::install_github("isoverse/isoreader")
devtools::install_github("isoverse/isoprocessor")
devtools::install_github("isoverse/isoprocessor")
library(isoprocessor) # processing isotope data files
library(tidyverse) # dplyr, tidyr, ggplot, etc.
library(openxlsx) # read/write from excel
library(plotly) # interactive plots
library(isoreader) # reading isotope data files
library(chemcal) # calculations from standard curve
install.packages("chemCal")
devtools::install_github("isoverse/isoprocessor")
library(isoprocessor) # processing isotope data files
library(tidyverse) # dplyr, tidyr, ggplot, etc.
library(openxlsx) # read/write from excel
library(plotly) # interactive plots
library(isoreader) # reading isotope data files
library(chemcal) # calculations from standard curve
library(chemcal) # calculations from standard curve
library(chemCal) # calculations from standard curve
# Chunk 1
library(tidyverse)
# Chunk 2
om23_dic_run1 <- readxl::read_excel("DIC 1ml run_corrected_data.xlsx") |>
mutate(
well =
case_when(
str_detect(Identifier1, "BA3A") ~ "BA3A",
str_detect(Identifier1, "BA4A") ~ "BA4A",
str_detect(Identifier1, "BA1B") ~ "BA1B",
str_detect(Identifier1, "BA1D") ~ "BA1D",
),
type = case_when(
str_detect(Identifier1, "-e") ~ "Anaerobic",
str_detect(Identifier1, "-f") ~ "Falcon Tube",
str_detect(Identifier1, "BA1D") ~ "Anaerobic",
),
depth = case_when(
str_detect(Identifier1, "250") ~ 250,
str_detect(Identifier1, "20") ~ 20,
str_detect(Identifier1, "150") ~ 150,
str_detect(Identifier1, "270") ~ 270,
str_detect(Identifier1, "120") ~ 170,
)
)
om23_dic_run1_samples <- om23_dic_run1 |>
filter(!is.na(well))
om23_dic_run1 |> write_csv("om23_DIC_d13C.csv")
om23_dic_run1 |> saveRDS(file = "om23_dic_run1.RDS")
om23_dic_run1 |> write_csv("om23_DIC_d13C.csv")
om23_dic_run1 |> saveRDS(file = "om23_dic_run1.RDS")
